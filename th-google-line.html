<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../th-d3-chart/th-d3-chart.html">
<link rel="import" href="../google-chart/google-chart.html">
<link rel="import" href="../th-data-utility/th-data-utility.html">
<link rel="import" href="../th-u-data-selector/th-u-data-selector.html">

<!--
Element providing a Thelma wrapper for the Google Line Chart.

##### Example

    <th-google-line></th-google-line>

@element th-google-line
@blurb Element providing a Thelma wrapper for the Google geochart.
@status alpha
@homepage http://nishacodes.github.io/th-google-regions
-->

<polymer-element name="th-google-line"  extends="th-d3-chart" attributes="input chartData labelValueSelection[0] labelValueSelection[1] color backgroundColor legend">
  <template> 
    <core-style ref="theme"></core-style>
    <link rel="stylesheet" href="th-google-line.css">
    <th-data-utility id="utility"></th-data-utility>

    <th-u-data-selector id="data_selector" input="{{chartData}}" selections="{{labelValueSelection}}"></th-u-data-selector>
    <!--
    <template if="{{dataAttributes}}">
      <div class="columnNames">
        <div>
           Label:  
          <template repeat="{{attr in dataAttributes}}">
            <span class="columnName datalabel {{attr | checkIflabelValueSelection[0]}}" on-click="{{togglelabelValueSelection[0]}}">{{attr}}</span>
          </template>
        </div>
        <br>
        <div>
          Value: 
          <template repeat="{{attr in dataAttributes}}">
            <span class="columnName {{attr | checkIfSelectedValue}}" on-click="{{togglelabelValueSelection[1]}}">{{attr}}</span>
          </template>
        </div>
      </div>
    </template>
  -->
    <google-chart id="googleChart" on-google-chart-render="{{chartReady}}" style="width:100%; height: 85%;"
          type='line'
          options= "{{options}}"
          data="{{_data}}">
    </google-chart>
  </template>

  <script>

    Polymer('th-google-line', {

      /**
       ** 'chartData' is the data represented by the map. 
       * @type {Array}
       *
       ** 'region' can be a country, state, or metro 
       * @type {String}
       *
       ** 'value' determines the color of the marker or fill
       * @type {Number}
       */
      chartData: [
        {"Year": "2014", "Sales": 100, "Profit": 50},
        {"Year": "2015", "Sales": 50, "Profit": 40},
        {"Year": "2016", "Sales": 300, "Profit": 200}
      ],

      /**
       * Data label for X axis
       * @type {String}
       */
      // dataLabels: ["Life Expectancy","Fertility Rate","Growth"],
      /**
       * 'chartWidth' refers to the width of the element container
       * @type {Number}
       */
      chartWidth: 280,
      /**
       * 'chartHeight' refers to the height of the element container
       * @type {Number}
       */
      chartHeight: 400,
      /**
       * 'backgroundColor' refers to the background color of the container
       * @type {String}
       */
      backgroundColor: "",
      /**
       * 'color' determines the range of the fill color of the regions
       * @type {String}
       */
      color: "",
      /**
       * 'legend' determines whether or not to display a legend
       * @type {Boolean}
       */
      legend: true,
      /**
       * 'numberFormat' refers to the number format of the legend min and max
       * @type {String}
       * @example: '.##'
       */
      numberFormat: "", 
      labelValueSelection: null,
      init: function() {
        this.inputChanged();
      },   
      ready : function() {
        //this._configureOptions();
        console.log('init');
        this.reformatData();
        this.$.data_selector.addEventListener('th-data-selection-changed', function() {
          console.log('??? label selected Handler');
          this.labelValueSelection = this.$.data_selector.selections;
          this.reformatData();
        }.bind(this));
        
      },
      /*
      chartReady: function() {
        console.log('chartReady');
        this._configureOptions();
        self.reformatData();
      },
      */
      inputChanged: function () {
        var self = this;
        self.chartData = self.input;
        console.log("inputchanged", self.chartData[0]);
        self.dataAttributes = Object.keys(self.chartData[0]);
        //self.getDefaultSelections();
        self.reformatData();
        self._configureOptions();
        
      },
      /*
      labelValueSelectionChanged: function() {
        console.log('labelValueSelectionChanged');
        this.inputChanged();
      },
      */
      
      /*
      getDefaultSelections: function(){
        console.log("get selections")
        
        var self = this;
        self.labelValueSelection[0] = self.labelValueSelection[0] || Object.keys(self.chartData[0])[0];
        self.labelValueSelection[1] = self.labelValueSelection[1] || Object.keys(self.chartData[0]).splice(1);
        
        self.labelValueSelection = [self.labelValueSelection[0], self.labelValueSelection[1]];
        console.log(self.labelValueSelection);
        console.log(self.labelValueSelection[0]);
        console.log(self.labelValueSelection[1]);
      },
      */
      /**
       * 'reformatData' converts chartData into the correct data structure for the map
       */
      reformatData: function(){
        var self = this; 

        console.log("reformat data", self.labelValueSelection);

        if(!self.labelValueSelection || !self.labelValueSelection[0] || !self.labelValueSelection[1]) {
          return;
        }
        var firstRow = self.labelValueSelection[1].map(function(item){ return item;}) ;
        
        self._data = self.chartData.map(function(item){
          var row = [];
          row.push(item[self.labelValueSelection[0]]);
          for(var i=0; i<self.labelValueSelection[1].length; i++){
            
            var unformattedValue = self.$.utility.unformatString(item[self.labelValueSelection[1][i]]);
            console.log(unformattedValue);
            row.push(unformattedValue);
          }
          return row;
        });

        firstRow.unshift(self.labelValueSelection[0]);
        self._data.unshift(firstRow);

       
      },
      /**
       * '_configureOptions' sets the appropriate options properties for the map, given the attribute values
       */
      _configureOptions: function(){
        var self = this,
            colors =  self.getColors();
        // Determine intermediate variables
        //self.color = self.color || [colors.accents[0], colors.accents[1]];

        self.minValue = self.minValue || 0;

        var textColorSetting = { color: colors.theme.foreground2, fontName: colors.theme.font, fontSize: '0.8em', opacity: 0.7};

        // Define chart options 
        self.options = {
          orientation: self.orientation,
          colors: colors.accents,
          backgroundColor: self.backgroundColor || "none",
          animation: {duration: "1000"},
          legend: { 
            position: "bottom",
            alignment: "center",
            numberFormat: self.numberFormat,
            textStyle: { 
              // color: colors.theme.foreground1, 
              fontName: colors.theme.font, 
              fontSize: '0.85em',
              stroke: 'none',
              strokeWidth: '0'            
            } 
          },
          vAxis: {
            format: "#,###.##" //TODO: add more options here and figure out how to format numbers in tooltips
          }
        };

        if (!self.legend) { self.options.legend = 'none';}
      },
      /**
       * 'getColors' gets the color theme from the global scope
       * @return {Object}
       */
      getColors: function(){
        colors = {};
        colors.theme = window.CoreStyle.g.theme;
        colors.accents = [];

        for (var color in colors.theme){
          if(/^accent/.test(color)){
            colors.accents.push(colors.theme[color]);
          }
        }

        colors.count = colors.accents.length;

        return colors;
      },
      /*
      checkIfSelectedValue: function(value){
        var self = this;
        if (self.labelValueSelection[1].indexOf(value) > -1){
          return "selectedValue";
        } else {
          return;
        }
      },
      checkIfSelectedLabel: function(value){
        var self = this;
        if (self.labelValueSelection[0] == value){
          return "labelValueSelection[0]";
        } else {
          return;
        }
      },
      togglelabelValueSelection[1]: function(e, detail, selection){
        var self = this;
        selection.classList.toggle('selectedValue');
        // TODO: this can be refactored... selected class is being handled in checkIfSelected filter
        var selected = self.shadowRoot.querySelectorAll('.selectedValue');
        self.labelValueSelection[1] = [].map.call(selected, function(item) { return item.textContent});
        console.log(self.labelValueSelection[1]);
        self.reformatData();
      },
      togglelabelValueSelection[0]: function(e, detail, selection){
        var self = this;
        var labels = self.shadowRoot.querySelectorAll('.datalabel');
        [].forEach.call(labels, function(item){ item.classList.remove('labelValueSelection[0]')});
        selection.classList.toggle('labelValueSelection[0]');
        // TODO: this can be refactored... selected class is being handled in checkIfSelected filter
        var selected = self.shadowRoot.querySelectorAll('.labelValueSelection[0]');
        self.labelValueSelection[0] = selection.textContent;
        // console.log(self.labelValueSelection[1]);
        self.reformatData();
      }
      */

    });

  
  </script>

</polymer-element>
